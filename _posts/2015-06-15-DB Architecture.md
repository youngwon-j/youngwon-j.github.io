---
layout: post
title: 데이터 아키텍쳐
---
###  아키텍쳐 개관

## Oracle 아키텍쳐

* 데이터베이스 : 디스크에 저장된 데이터 집합
* 인스턴스 : 공유메모리 영역과 이를 액세스 하는 프로세스 집합
* 쉽게 말해 데이터베이스는 실제 데이터가 저장되는 공간이고 인스턴스는 작업(프로세스)이 이루어지는 공간

## SQL Server 아키텍쳐

* 쓰레드 기반 아키텍쳐
* SQL Server : 하나의 인스턴스 당 32767개의 데이터베이스를 정의해 사용할 수 있다.
* 데이터베이스를 만들때 마다 데이터 파일, 트랜잭션 로그 파일이 생성되며, 저장할 데이터가 많으면 보조 데이터 파일 추가 가능
** 데이터 파일 : mdf 확장자
** 로그 파일 : ldf 확장자
** 보조 데이터 파일 : ndf 확장자

###  프로세스
* 서버 프로세스와 백그라운드 프로세스로 나뉜다.
* 서버 프로세스는 사용자의 명령을 처리
* 백그라운드는 주어진 명령을 수행

## 서버 프로세스

* 사용자 프로세스와 통신하면서 사용자의 각종 명령을 처리 ( SQL Server에선 Worker 쓰레드가 같은 역할 )
* SQL 파싱 > Optimizing > 블록 읽기 > 데이터 정렬 > 네트워크를 통해 전송 하는 일련의 과정 수행
* 클라이언트가 서버 프로세스와 연결하는 방식은 전용 서버 방식 , 공유 방식이 존재
** 전용 서버 방식 ( Dedicated Server
*** 리스너가 연결 요청을 받은 후 > 서버 프로세스를 생성, 생성된 프로세스는 전용 서비스를 제공
*** SQL 수행 시 마다 연결/해제 반복 시 비효율적이므로 Connection Pooling 기법을 사용해야한다.
** 공유 서버 방식 ( Shared Server )
*** 하나의 서버 프로세스를 여러 사용자 세션이 공유
*** Connection Pooling기법이 DBMS 내부에 구현된 것
*** Dispatcher > SGA 에 있는 Request Queue에 등록됨 > 사용가능한 서버 프로세스가 명령 수행 후 결과를 Response Queue에 등록 >  Dispatcher가 사용자에게 전달

## 백그라운드 서비스

* System Monitor ( SMON ) : 장애가 발생한 시스템 가동 시 인스턴스 복구  및 세그먼트, 익스텐트 모니터링
* Process Monitor ( PMON ) : 이상이 생긴 프로세스가 사용하던 리소스 복구
* Database Writers ( DBWn ) : 버퍼 캐시에 있는 Dirty 버퍼를 데이터 파일에 기록
* Log Writer ( LGWR ) : 로그 버퍼 엔트리를 Redo 로그 파일에 기록
* Archiver ( ARCn ) 꽉찬 Redo 로그가 덮어쓰여지기 전에 Archive 로그 디렉토리로 백업
* Checkpoint ( CKPT ) : 이전 CheckPoint가 일어난 시점 이후 DB 변경사항을 데이터 파일에 기록하도록 트리거링, 기록이 완료되면 어디까지 기록했는지를 저장. 장애가 발생하면 마지막 체크포인트 이후 로그 데이터만 디스크에 기록함으로써 인스턴스르 ㄹ복구할 수 있도록 하는 용도로 사용됨.
* Recoverer ( RECO ) : 분산 트랜잭션 중 발생한 문제를 해결

###  파일 구조
## 데이터 파일

* 블록 ( 페이지 )
** 대부분의 DBMS에서 I/O는 블록단위로 이루어지며, SQL의 성능을 좌우하는 가장 큰 지표는 엑세스하는 블록 개수.
*** 오라클에서는 2KB, 4KB, 8KB, 16KB, 32KB, 64KB 의 다양한 블록 크기 사용
*** SQL Server 에서는 8KB 단일크기 사용
** 액세스해야 할 블록 개수는 옵티마이저의 판단에 가장 큰 영향을 미침

* 익스텐트
** 테이블 스페이스로부터 공간을 할당하는 단위 ( 공간이 부족할 때, 공간을 제공받는 단위 )
*** 균일 익스텐트 : 64kb 이상 공간을 필요로 하는 테이블 , 인덱스를 위해 사용함
*** 혼합 익스텐트 : 한 익스텐트에 할당된 8개 페이지를 여러 오브젝트가 나누어 사용하는 형태
*** 모든 테이블이 처음에는 혼합 익스텐트로 시작하지만 64KB를 넘으면서 균일 익스텐트 사용

* 세그먼트
** 테이블, 인덱스 처럼 저장공간을 필요로 하는 데이터베이스 오브젝트
** 한개 이상의 익스텐트를 사용
** 테이블 생성 시 내부적으로는 테이블 세그먼트가 생성되고 인덱스 생성 시 내부적으로 인덱스 세그먼트가 생성됨

* 테이블 스페이스
** 세그먼트를 담는 콘테이너로서 여러 데이터 파일로 구성됨
** 사용자는 세그먼트를 위한 테이블 스페이스만 지정하면, 실제 값을 저장할 데이터 파일 선택 후 익스텐트 할당 하는 것은 DBMS 의 몫

## 임시 데이터 파일

* 대량의 정렬, 해시 작업 등을 수행하다 메모리가 부족해지면 중간 결과집합을 저장하는 용도
* 임시로 저장했다가 자동으로 삭제됨
* Redo정보를 생성하지 않기 때문에 복구불가.

## 로그파일

* Redo 로그 : DB 버퍼 캐시에 가해지는 모든 변경사항을 기록하는 파일 ( SQL Server는 트랜잭션 로그라고 부름 )
* 로그 기록은 Append 방식으로 이루어지기때문에 빠른 속도를 가짐
* Append 방식으로 기록 후, DBWR, Checkpoint 를 이용해 배치 방식으로 데이터 파일간 동기화 수행
** Oneline Redo 로그
*** 변경사항이 데이터파일에 기록되지 않은 상태에서 정전 등으로 인스턴스가 비정상 종료될 때 등과 같은 상황에서 사용됨
*** 마지막 체크포인트 이후부터 사고발생 직전까지 수행되었던 Redo 로그를 이용해 재현하며 '캐시복구' 라고 부름
*** 두개 이상의 파일로 구성되며, 모든 파일이 꽉 차면 첫번째 파일부터 재사용하는 라운드로빈 방식 사용
** 트랜잭션 로그
*** 주 데이터 파일마다 트랜잭션 로그가 생기며 ldf 확장자 사용
*** 가상 로그 파일이라 불리는 더 작은 세그먼트로 나뉘며 로그파일의 개수가 너무 작아지지 않게 하는게 좋다.
** Archived Redo 로그
** Oneline Redo 로그가 재사용 되기 전 다른 위치로 백업해둔 파일.
** 물리적인 저장 매체에 문제가 생겼을 때, 데이터베이스 복구를 위해 사용됨

###  메모리 구조
* 메모리 구조는 메모리영역 / 프로세스 전용 메모리 영역으로 구분됨
** 시스템 공유 메모리 영역
*** 여러 프로세스가 동시에 사용할 수 있는 메모리 영역. (SGA, Memory Pool이라고 부름)
** 프로세스 전용 메모리 영역
*** 서버 프로세스가 자신만의 전용 메모리 영역을 가지는 것 ( PGA )
*** 데이터 정렬 및 세션, 커서 상태정보 저장 용도로 사용

## DB 버퍼 캐시 ( DB Buffer Cache )

* 데이터 파일로부터 읽어들인 데이터 블록을 담는 캐시 영역
* 모든 사용자 프로세스는 서버 프로세스를 통해 DB 버퍼 캐시의 버퍼 블록을 동시에 엑세스 가능
* 모든 블록 읽기는 기본적으로 버퍼 캐시를 통해 이루어진다.
* 변경된 블록을 Dirty 블록이라 한다.
* 모든 버퍼는 Free버퍼, DIrty버퍼, Pinned버퍼 상태에 놓이게 된다.
** Free 버퍼 : 데이터가 읽히지 않아 비어있는 상태이거나, 언제든지 덮어써도 되는 상태
** Dirty 버퍼 : 데이터 파일 블록과 동기화가 필요한 버퍼 블록
** Pinned 버퍼 : 읽기, 쓰기 작업이 진행중인 블록

* LRU 알고리즘 ( Least Recently Used ) 을 사용하여 Free 버퍼를 찾음
**LRU 알고리즘은 Least Recently Used의 약자로 기억장치 바깥으로 내보내야할 페이지를 선정할 때 가장 오랜 기간 사용되지 않았던 페이지부터 교체하는 페이지 교체 알고리즘. 이는 일반적으로 가장 오랫동안 액세스 되지 않았던 페이지는 앞으로도 액세스 되지 않을 확률이 제일 크다는 것에 기반한 것.

## 공유 풀 ( Shared Pool )

* 딕셔너리 캐시 / 라이브러리 캐시로 구성, LRU 알고리즘 사용
** 딕셔너리 캐시 : 테이블, 인덱스, 테이블 스페이스, 세그먼트, 익스텐트 등의 메타 정보를 저장
** 라이브러리 캐시 : 사용자가 수행한 SQL 문 및 실행계획, 저장 프로시저를 저장

## 로그 버퍼

* 로그 또한 파일에 바로 기록되는 것이 아니라 로그버퍼를 거쳐 기록됨
* Ex ) Redo 로그 버퍼에 기록 > LGWR 프로세스가  Redo 로그 파일에 기록
* 데이터를 변경하기 전, 변경사항을 항상 로그 버퍼에 기록해야함.
* Commit 시점 전에는 항상 로그파일에 기록되어야 함

## PGA

* 각 Oracle 서버 프로세스는 자신만의 PGA 메모리 영역을 할당받음.
* 다른 프로세스와 공유되지 않는 독립적인 메모리이기 때문에 빠른 속도를 가진다.
** User Global Area (UGA)
*** 세션이 프로세스 개수보다 많아질 때, 각 세션을 위한 독립적인 메모리 공간
** Call Global Area (CGA)
*** Call 이 진행되는 동안 필요한 데이터를 담는 용도
** Short Area
*** Sort 오퍼레이션이 진행되는 동안 공간이 부족할 때 마다 할공간을 당하는 용도

###  대기 이벤트
* 각 프로세스들은 다른 프로세스가 일을 마칠 때까지 대기하는 경우가 생기는데, 이때 Sleep 상태가 됨.
* Sleep 상태에는 상태, 시간정보가 공유 메모리 영역에 저장됨
* Response Time = Server Time (수행시간) + Wait Time (대기시간) = CPU Time(수행시간) + Queue Time(대기시간)
