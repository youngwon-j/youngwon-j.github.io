---
layout: post
title: 데이터모델링
---
### 제 1절 성능 데이터 모델링의 개요.


## 성능데이터모델링의 정의.

* 데이터베이스에서 기본적으로 설계단계에서 성능을 고려하지않고 설계를 해서는 안된다.
* 일반적으로 성능이라고 하면 데이터 조회의 성능을 의미. 그 이유는 입력/수정/삭제는 빈번하지않기때문.
* 성능 데이터 모델링이란 정규화, 반정규화, 테이블통합, 테이블분할, 조인구조,PK, FK 등 여러 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는것.

## 성능데이터모델링 수행시점

* 성능향상 비용은 프로젝터 초반부에 할 수록 저비용

## 성능데이터모델링 고려사항

* 정규화(Normalization) 를 정확하게 수행한다.
* 데이터베이스 용량산정을 수행한다.
* 트랜잭션 유형을 파악한다.
* 용량, 트랜잭션을 고려하여 반정규화를 수행한다.
* 이력모델의 조정, PK?FK조정, 슈퍼타입/서브타입 등을 조정
* 성능관점에서 데이터 모델을 검증한다.

### 제 2절 정규화와 성능

## 정규화를 통한 성능 향상 전략

* 정규화를 하는 이유는 데이터 중복성 제거 / 데이터를 관심사별로 처리하기 위함.
* 운영 중 성능저하의 경우에는 사례별로 유의하여 반정규화를 수행
* 정규화된 테이블은 데이터 처리시 속도가 빨라질 수도 있고 느려질 수도 있다. ( 일반적으로 반정규환테이블에 비해 C/U/D 는 향상, 조건에 따라 R은 저하될 수도 있다 )
* 몇가지예시에서 볼 수 있듯, 정규화 시 무조건 조회 성능이 떨어진다는 것은 잘못된 고정관념이다.

## 함수적 종속성에 근거한 정규화 수행

* 함수적 종속성이란 데이터들이 어떤 기준값에 의해 종속되는 현상.
* 예를 들자면 유니크한 주민번호에 이름,출생지, 호주가 종속된다면 주민등록번호 -> (이름, 출생지, 호주) 로 나타낼 수 있다.
* 데이터는 속성간의 함수종속성에 근거하여 정규화 되어야만 한다.

### 제 3절 반정규화와 성능


## 반정규화를 통한 성능향상 전략

* 반정규화 ( De-Normalization )은 정규화를 수행하지 않은 모델을 지칭
* 성능을 향상시키기 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정을 의미
* 반정규화를 적용하는 이유
** I/O량이 많아 성능이 저하되는 경우
** 경로가 너무 멀어 조인으로 인한 성능저하가 예상되는 경우
** 칼럼을 계산하여 읽을 때 성능이 저하될것이 예상되는 경우
* 반정규화를 수행하지 않는 경우 성능이 저하되거나, 추후 수정에 따른 노력비용이 많이 들게된다.
* 무분별한 반정규화의 경우 무결성을 깨트릴 수 있으므로 주의해야한다.
* 반정규화의 절차
** 1. 반정규화 대상 조사
*** 범위처리빈도수 조사
**** 자주 처리되는 테이블에 접근하는 프로세스가 많고, 일정 범위만 조회하는 경우 반정규화 검토
*** 대량의 범위처리 조사
*** 통계성 프로세스 조사
*** 테이블 조인 개수 조사
** 2. 다른 방법 유도 검토
*** View 테이블
*** 클러스터링 적용
*** 인덱스 적용
*** 응용 어플리케이션(캐쉬 사용)
** 3. 반정규화 적용
*** 테이블 , 속성, 관계 반정규화

## 반정규화 기법

* 테이블 반정규화
** 테이블 병합
** 테이블 분할
** 테이블 추가

*컬럼 반점규화
** 중복컬럼 추가
** 파생컬럼 추가
** 이력 테이블 컬럼 추가
** PK 에 의 한 컬럼 추가
** 응요잇스템 오작동을 위한 컬럼 추가

* 관계 반정규화
** 중복관계 추가

### 제 4절 대량 데이터에 따른 성능

## 대량 데이터 발생에 따른 테이블 분할 개요

* 설계가 잘 되어있는 데이터 모델이라 하더라도 대량의 데이터가 하나의 테이블, 하드웨어에 집약된 경우 성능저하 > 트랜잭션이 분산 처리될 수 있도록 테이블단위에서 분할의 방법을 적용할 필요가 있다.
* 한 테이블에대량의 데이터가 존재하는 경우, 인덱스 Tree구조가 너무 커져 효율성 저하
* 한 테이블에 많은 수의 컬럼이 존재할 경우 디스크의 여러 블록에 데이터가 존재하므로 I/O량이 많아져 성능 저하
* 대량의 데이터가 처리되는 테이블의 성능저하 이유는 I/O량이 많아지기 때문
* 로우체이닝 / 로우 마이그레이션은 불필요한 I/O를 일으킨다.
** 로우 체이닝 : 로우길이가 너무 길어 데이터블록 두개 이상에 걸쳐 하나의 로우가 저장되는 현상
** 로우 마이그레이션 : 데이터 블록의 수정이 발생하면, 수정된 데이터를 해당 데이터블록에서 저장하지 못하고 다른 블록의 빈공간을 찾아 저장하는 방식

## 한 테이블에 많은 수의 컬럼이 있는 경우

* 트랜잭션이 어떤 컬럼에 집중적으로 발생하는지 분석하여 테이블을 쪼개어주면 디스크I/O가 감소, 성능이 개선됨.

## 대량 데이터 저장 및 처리로 인한 성능

* 테이블에 많은 양의 데이터가 예상될 경우, 파티셔닝 및 PK기준 테이블 분할을 적용할 수 있다.
* Range Partition - 날짜 또는 숫자값으로 테이블이 분리되어 있을 경우
** 데이터 보관주기에 따른 테이블관리 용이
* List Partition - 다량의 PK가 있고 , 그에 따른 대량의 데이터가 있을 때
** 데이터를 특정값 ( PK )에 따라 분리저장할 수 있으나 Range Partitioning 처럼 데이터 보관주기에 따라 쉽게 삭제할 수 없다.
* Hash Partitioning
** 해슁 알고리즘에이 적용되어 테이블이 분리
** 설계자는 어떤 테이블에 데이터가 들어갔는지 알 수 없으며 Range Partitioning 처럼 데이터 보관주기에 따라 쉽게 삭제할 수 없다.

## 테이블에 대한 수평/수직분할 절차

* 데이터 모델링을 완성한다
* 데이터베이스 용량을 산정한다
* 대량 데이터가 처리되는 테이블에 대해 트랜잭션 처리 패턴을 분석한다.
* 컬럼 단위로 집중화된 처리가 발생하는지, 로우단위로 집중화된 처리가 발생하는지 분석하여 집중화된 단위로 테이블을 분리한다.

### 데이트베이스 구조와 성능

## Extended ER 모델

** 업무를 구성하는 데이터 특징을 공통과 차이점의 특징을 고려하여 효과적으료 표현할 수 있다.
** 공통의 부분은 슈퍼타입, 공통으로부터 상속받아 다른 엔티티와 차이가 있는 속성은 별도의 서브엔티티로 구성
** 논리적인 데이터 모델에서 이용되는 형태이며 분석단계에서 많이 쓰인다.
** 슈퍼 / 서브타입에 대한 변환을 잘못할 시, 트랜잭션을 고려하지 않으면 성능이 저하된다.
*** 트랜잭션은 일괄 처리이지만 테이블이 개별로 유지되면 Union 연산에 의해 성능저하
*** 트랜잭션은 항상 서브타입으로 개별처리이지만 테이블이 하나로 통합되어 있으면 성능저하
*** 트랜잭션은 항상 슈퍼+서브타입 공통 처리이지만 테이블이 개별로 유지되거나 하나로 통합되어있으면 성능저하

* 데이터 양이 많이 존재하고, 지속적으로 증가하는 양이 많다면 슈퍼타입 / 서브타입에 대해 물리적인 데이터 모델로 변환해야한다.
* 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
** 슈퍼타입과 서브타입 각각에 대해 독립적인 트랜잭션이 발생되면 1:1 관계로 개별구성
* 슈퍼타입 + 서브타입에 대해 발생하는 트랜잭션에 대해서는 슈퍼타입 + 서브타입 테이블로 구성
* 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성
* 슈퍼 / 서브타입 데이터 모델의 변환타입 비교
|| 구분 || OneToOne Type || Plus Type || Single Type
| 특징 | 개별 테이블 유지 | 슈퍼 + 서브타입 테이블 | 하나의 테이블 |
| 확장성 | 우수함 | 보통 | 나쁨 |
| 조인성능 | 나쁨 | 나쁨 | 우수함 |
| I/O량 성능 | 좋음 | 좋음 | 나쁨 |
| 관리용이성 | 좋지않음 | 좋지않음 | 좋음 (1개) |
| 트랜잭션 유형에 따른 선택방법 | 개별 테이블로 접근이 많은 경우 | 슈퍼+서브 형식으로 데이터 처리할 경우 | 전체를 일괄적으로 처리하는 경우 |

## 인덱스 특성을 고려한 PK/FK 데이터베이스 성능 향상

* 인덱스 = 효과적으로 데이터를 조회할수 있도록 접근경로를 제공하는 오브젝트
* 일반적으로 BTree를 사용
* PK/FK 컬럼 순서의 중요성을 인지하지 못한 채로 모델링이 되어있는 상태로 DDL 을 생성하면 성능에 문제를 유발.
* 앞쪽에 위치한 속성이 비교자로 되어있어야 인덱스가 좋은 효율을 나타냄
* PK 순서를 인덱스 특징에 맞게 고려하지 않고 바로 그대로 생성하게 되면, 테이블에 접근하는 트랜잭션의 특징에 효율적이지 않은 인덱스가 생성되어 비효율적이다.

## 물리적인 테이블에 FK 제약이 걸려있지 않을 경우 인덱스 미생성으로 성능 저하

* 물리적인 테이블에 FK를 사용하지 않아도 데이터 모델 관계에 의해 상속받은 FK 속성은 SQL Where절에서 조인으로 이용되는 경우가 많이 있으므로 FK 인덱스를 생성해야 성능이 좋은 경우가 많음
** FK 에도 반드시 FK인덱스를 생성해야함.

### 분산 데이터베이스와 성능

## 분산 데이터베이스의 개요.

*분산 데이터베이스의 정의
** 여러곳으로 분산되어 있는 DB를 하나의 가상 시스템으로 사용할 수 있도록 함
** 논리적으로 동일한 시스템이지만 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 DB들의 모임.

## 분산 데이터베이스의 투명성(Transparency)

* 분산데이터베이스가 되기 위해서는 아래 6가지 투명성을 만족해야한다.
** 분할투명성 ( 단편화 ) 하나의 논리적 Relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 site에 저장
** 위치 투명성 : 사용하려는 데이터의 저장 장소 명시 불필요, 위치정보가 System Catalog에 유지되어야 함
** 지역사상 투명성 : 지역 DBMS와 물리적 DB 사이의 Mapping 보장. 각 지역 시스템 이름과 무관한 이름 사용 가능
** 중복 투명성 : DB객체가 여러 site에 중복되어 있는지 알 필요가 없는 성질
** 장애 투명성 : 구성요소의 장애에 무관한 Transaction의 원자성 유지
** 병행 투명성 : 다수 Transaction 동시 수행시 결과의 일관성 유지, Time Stamp, 분산 2단계 Locking을 이용 구현

## 분산 데이터베이스의 적용 방법 및 장단점

* 업무의 특성에 따라 데이터베이스 분산구조를 선택적으로 설계하는 능력이 필요
* 분산 데이터베이스 장단점
* 장점
** 지역 자치성, 점증적 시스템 용량 확장
** 신뢰성과 가용성
** 효용성과 융통성
** 빠른 응답 속도, 통신비용 절감
** DB가용성 및 신뢰성 증가
** 시스템 규모의 적절한 조절
** 각 지역 사용자의 요구 수용 증대
* 단점
** SW 개발비용
** 오류의 잠재성 증대
** 처리 비용 증대
** 설계, 관리의 복잡성과 비용
** 불규칙한 응답 속도
** 통제의 어려움
** 데이터 무결성에 대한 위협

## 분산 데이터베이스 활용 방향성

* 업무적 특징에 따라 분산 데이터베이스를 활용하는 기술 필요

h4  데이터베이스 분산구성의 가치
* 통합된 데이터베이스에서 제공할 수 없는 빠른 성능을 제공하는것이 핵심 가치

##분산 데이터베이스 적용 기법

* 테이블 위치 분산, 테이블 분할 분산, 테이블 복제 분산, 테이블 요약 분산
** 가장 많이 사용하는것이 테이블 복제 분할 분산.

* 테이블 위치 분산
** 테이블의 위치를 각각 다르게 위치
** 정보를 이용하는 형태가 각 위치별로 차이가 있을 경우 이용
*테이블 분할 분산
** 테이블 위치만 다른곳에 두는 것이 아닌 각각 테이블을 쪼개어 분산하는 방법
** 테이블을 나누는 기준에 따라 수평 / 수직분할
*** 수평분할  - 특정값 기준으로 로우(Row)를 분리 ( 컬럼은 분리되지 않음 )
*** 각 Node별로 이용하는 Row가 다를 때 이용
*** 수직분할 - 특정값 기준으로 컬럼을 분리한다. ( 로우는 분리되지 않음 )
*** 컬럼 기준 분할이기 때문에 각 테이블에는 동일 PK 구조 및 값을 가지고 있어야함
* 테이블 복제 분산
** 동일 테이블을 다른 지역 및 서버에서 동시에 생성 / 관리하는 유형
** 마스터 DB에서 테이블의 일부 내용만 다른 지역, 서버에 위치시키는 부분복제 / 마스터 DB의 테이블을 각 지역, 서버에 존재시키는 광역복제가 존재
*** 부분복제
**** 통합 테이블을 한군데에 가지고 있으면서 , 각 서버별로는 서버에 해당된 로우를 가지고 있는 형태
**** 각 서버에 대한 처리가 용이할 뿐 아니라 전체 데이터에 대한 통합 처리도 효율적임
**** 복사 시 많은 부하가 발생하므로 복사의 경우 야간 배치작업에 의해 수행
*** 광역복제
**** 통합된 테이블을 한군데에 가지고 있으면서도, 각 서버에서도 동일한 데이터를 모두 가지고 있는 경우
**** 복사 시 많은 부하가 발생하므로 복사의 경우 야간 배치작업에 의해 수행
* 테이블 요약 분산
* 분석요약 : 동일한 테이블 구조를 가지고 있으면서 분산되어있는 동일한 내용의 데이터를 이용하여 통합된 데이터 산출
* 통합요약 : 분산된 다른 내용의 데이터를 이용하여 통합된 데이터를 산출

## 분산 데이터베이스를 적용하여 성능이 향상된 사례

* 성능이 중요한 사이트에적용해야한다
* 공통 코드, 기준 정보, 마스터 데이터 등에 대해 분산환경을 구성하면 성능이 좋아진다.
* 실시간 동기화가 요구되지 않을 떄 좋다.
* 특정 서버에 부하가 집중될 시 부하를 분산할 때에 좋다.
* 백업사이트를 구성할 떄 간단하게 분산기능을 적용하여 구성할 수 있다.

출처: "SQL 전문가 가이드, 2013 Edition", 서강수, 한국데이터베이스진흥원, 2013



