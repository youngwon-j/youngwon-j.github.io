---
layout: post
title: SQL 파싱
---
## SQL 처리과정
* SQL 옵티마이져는 실행계획에 의해 SQL(Structured Query Language) 를 수행한다.
* 실행계획을 통해 옵티마이져가 수립한 CRUD 의 ACCESS 경로를 알 수 있다.

## SQL 파싱
* 시스템 공유 메모리에서 SQL과 실행계획이 캐싱되는 영역을 '라이브러리 캐시', '프로시저 캐시'라고 부른다.
* SQL 실행절차

* 소프트 파싱 ( Soft Parsing ) : SQL , 실행계획을 캐시에서 찾아 곧바로 실행단계로 넘어감
* 하드 파싱 ( Hard Parsing ) : SQL, 실행계획을 캐시에서 찾지 못해 최적화 과정을 거친 후 실행과정으로 넘어감
* 라이브러리 캐시는 해시구조로 관리되기 때문에, SQL 을 찾을 때는 SQL 문장을 해시 함수에 입력 후 반환된 해시값을 이용해 해시버켓 탐색

## SQL 최적화 ( Optimizing )
* Optimizer에 의해 옵티마이징 되며, 요청된 SQL을 가장 빠르고 효율적으로 수행할 처리경로를 선택해주는 DBMS 핵심엔진
* 최적화된 SSQL 실행계획을 수립하기에는 여러 비용이 들어가므로, 파싱 과정을 거친 SQL과 실행계획은 여러사용자가 공유, 재사용 할 수 있도록 캐싱.

## 캐싱된 SQL 공유
### 실행 계획 공유 조건
        * SQL 수행 절차
        ** 1. 문법 오류 검사 ( Syntax 검사 )
        ** 2. 해시 함수로 부터 반환된 해시 값으로 라이브러리 캐시 내 해시버킷 탐색
        ** 3. 탐색된 해시버킷 탐색하면서 같은 SQL 문장 탐색
        ** 4. SQL 문장을 찾았다면 저장된 실행계획으로 SQL문 실행
        ** 5. SQL 문장을 찾지 못했다면 최적화 ( Optimizing ) 수행
        ** 6. 최적화를 거친 SQL과 실행계획을 탐색한 해시버켓 체인에 연결
        ** 7. 최적화한 실행계획으로 SQL문 실행
* 캐시에서 SQL문을 찾기 위해서 사용되는 키 값은 'SQL 문장 그 자체' ( SQL 전체 문자열이 이름 역할 )
* SQL 문장 중간에 작은 공백문자 하나만 추가되더라도 DBMS는 서로다른 SQL 문장으로 인식하기 때문에 캐싱된 버전 사용하지 못하므로 주의

### 실행계획을 공유하지 못하는 경우.
* 공백 문자 또는 줄바꿈
* 대소문자 구분
* 주석
* 테이블 Owner 명시
* 옵티마이져 힌트 사용
* 조건절 비교 값

## 바인드 변수 사용하기
### 바인드 변수 중요성
* 파라미터 Driven 방식으로 SQL 을 작성하는 방법.
* 바인드 변수를 사용하며 ㄴ하나의 프로시저를 공유하면서 반복, 재사용할 수 있어 효율적임
** SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'youngwonjang' ( X )
** SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'LOGIN_ID' ( O )
* 바인드 변수를 사용하면 처음 ㅜ행한 세션이 하드파싱을 통해 실행계획을 생성 후 캐싱하므로써 재사용성이 높아진다.
* 시스템 전반의 CPU 및 메모리 사용률을 낮춰 데이터베이스의 확장성을 높히므로 동시접속자가 많을 떄 효과는 절대적
* 바인드 변수를 쓰지 않아도 되는 경우
** Long Running 쿼리 > 파싱 소요시간이 쿼리 소요시간에 비해 비중이 낮고 수행빈도가 낮아 하드파싱이 캐싱 부하를 일으킴
** 조건절 컬럼 값이 종류가 소수일 때
* 단순 매개 변수화 : 리터럴 SQL 위주로 애플리케이션을 개발할 경우에 대비해 각 DBMS는 조건절 비교 값이 리터럴 상수일 때, 이를 자동으로 변수화 시켜주는 기능 제공
** 단순 매개 변수화를 사용할 경우, 실행계획이 갑자기 바뀌어 기존에 잘 수행되던 쿼리가 느려지는 경우도 존재
** 사용자가 의도적으로 사용한 상수도 변수화되면서 문제를 일으키기도 함

### 바인드 변수 사용 시 주의사항
* 바인드 변수를 바인딩하는 시점은 최적화 이후 > 나중에 반복 수행될 떄 어떤 값이 입력될지 알 수 없어 옵티마이저는 조건절 컬럼의 데이터 분포가 균일하다는 가정 하에 최적화 수행
* 이는 컬럼에 대한 히스토그램 정보가 딕셔너리에 저장되어 있어도 활용하지 못한다는 것  > 컬럼 분포가 균일하지 않을 때 실행시점에 바인딩되는 값에 따라 쿼리 성능이 차이남

### 바인드 변수 부작용을 극복하기 위한 노력
* Oracle 9i 부터 바인드 변수 peeking 기능 도입
** 첫번째 SQL이 수행될 떄 변수값을 보고, 그 컬럼 분포를 이용해 실행계획 결정
** 처음 실행될 떄 입력된 값과 전혀 다른 분포를 갖는 값이 나중에 입력되면 쿼리성능이 갑자기 저하
** 쿼리 수행빈도가 낮아 캐시에서 자주 밀려나도, 실행계획이 수시로 바뀔 수 있기 때문에 위험함
** 쿼리 수행 전 확인하는 실행계획은 바인드 변수 peeking 기능이 적용되지 않은 실행계획
* Oracle 11g 부터 '적응적 커서 공유'기능 도입
** 입력된 변수 값의 분포에 따라 다른 실행계획이 사용되도록 처리

## Static SQL과 Dynamic SQL
### Static SQL
* String 형 변수에 담지 않고 코드 사이에 직접 기술한 SQL문 ( Embeded SQL )
### Dynamic SQL
* String 형 변수에 담아서 기술하는 SQL문
* String 변수를 사용하므로 조건에 따라 SQL 문을 동적으로 바꿀 수 있고, 런타임 시 사용자로부터 SQL 문의 일부, 전부를 입력받아 실행가능

## 어플리케이션 커서 캐싱
* 같은 SQL을 여러번 반복 수행할 때 라이브러리 캐시에 공유된 버전을 찾아 가볍게 실행 가능하지만 SQL 문법 , 의미 오류화깅ㄴ 후 해싱값으로 실행계획을 찾고, 메모리 공간을 할당하는 작업의 반복은 비효율적
* 위 과정을 생략하고 빠르게 SQL 문을 수행하는 방법이 '애플리케이션 커서 캐싱'
* 자바에서는 Implicit Caching 옵션을 사용하여 구현 가능


참조 : SQL 전문가 가이드 2013 Edition , KODB(한국데이터베이스진흥원)
